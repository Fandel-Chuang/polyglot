# polyglot/文达 AI编程知识集

## 🤖 AI使用说明

本文档专门为AI助手设计，提供polyglot/文达语言的完整语法规范和编程范例，帮助AI正确理解和生成polyglot/文达代码。

---

## 📋 语言基本信息

**语言名称**: polyglot (英文版) / 文达 (中文版)
**文件扩展名**: `.pg` (英文) / `.文达` (中文)
**版本**: v1.0.0
**类型**: 编译型语言，符号化语法
**内存管理**: 智能指针 + 引用计数，零垃圾收集器

---

## 🎯 核心设计理念

1. **符号化语法** - 用直观符号替代英文关键字
2. **内存安全** - 编译期循环引用检测 + 智能指针
3. **三符号赋值** - `=`强引用、`~=`弱引用、`:=`值拷贝
4. **中文编程** - 完整支持全角符号和中文标识符

---

## 📖 完整语法规范

### 1. 模块导入 `>>`
```rust
// 英文版
>> "iostream"
>> "vector"
>> "string"

// 中文版
》》 "输入输出流"
》》 "向量"
》》 "字符串"
```

### 2. 变量声明 `?`
```rust
// 基本声明
name := "Alice"              // 自动类型推导
? age: i32 = 25              // 显式类型
? height: f64 = 1.75         // 浮点数

// 中文版
姓名 ：=  "爱丽丝"
？ 年龄： 整数 = 25
？ 身高： 浮点数 = 1.75
```

### 3. 常量声明 `*`
```rust
// 英文版
* PI = 3.14159
* MAX_PLAYERS = 100

// 中文版
＊ 圆周率 = 3.14159
＊ 最大玩家数 = 100
```

### 4. 函数定义 (无关键字)
```rust
// 英文版
main() {
    print("Hello World")
    <- 0
}

calculate_damage(base: f64, multiplier: f64) -> f64 {
    <- base * multiplier
}

// 中文版
主函数（） {
    打印（"你好世界"）
    《- 0
}

计算伤害（基础： 浮点数， 倍率： 浮点数） －》 浮点数 {
    《- 基础 ＊ 倍率
}
```

### 5. 结构体定义 `@`
```rust
// 英文版
@ Player {
    name: string,
    health: f64,
    position: Vector3
}

// 中文版
@ 玩家 {
    姓名： 字符串，
    生命值： 浮点数，
    位置： 三维向量
}
```

### 6. 方法实现 `&`
```rust
// 英文版
& Player {
    Player(name: string, health: f64) {  // 构造函数
        _.name = name
        _.health = health
        _.position = Vector3 { x: 0.0, y: 0.0, z: 0.0 }
    }

    ~Player() {  // 析构函数
        print("Player destroyed: " + _.name)
    }

    take_damage(amount: f64) {
        _.health -= amount
        (_.health <= 0.0) ? {
            _.health = 0.0
            print(_.name + " is dead!")
        }
    }

    is_alive() -> bool {
        <- _.health > 0.0
    }
}

// 中文版
& 玩家 {
    玩家（姓名： 字符串， 生命值： 浮点数） {
        ＿．姓名 ＝ 姓名
        ＿．生命值 ＝ 生命值
        ＿．位置 ＝ 三维向量 { 横： 0.0， 纵： 0.0， 高： 0.0 }
    }

    ～玩家（） {
        打印（"玩家已销毁： " ＋ ＿．姓名）
    }

    受到伤害（伤害量： 浮点数） {
        ＿．生命值 －＝ 伤害量
        （＿．生命值 ＜＝ 0.0）？ {
            ＿．生命值 ＝ 0.0
            打印（＿．姓名 ＋ " 已死亡！"）
        }
    }

    是否存活（） －》 布尔 {
        《- ＿．生命值 》 0.0
    }
}
```

### 7. 接口定义 `%`
```rust
// 英文版
% Drawable {
    draw() -> void
    get_bounds() -> Rectangle
}

// 中文版
％ 可绘制 {
    绘制（） －》 空
    获取边界（） －》 矩形
}
```

### 8. 枚举定义 `#`
```rust
// 英文版
# PlayerState {
    Idle,
    Moving,
    Attacking,
    Dead
}

// 中文版
＃ 玩家状态 {
    闲置，
    移动，
    攻击，
    死亡
}
```

### 9. 控制流语句

#### 条件语句 `()?{}`
```rust
// 英文版
(player.health > 0) ? {
    print("Player is alive")
} : {
    print("Player is dead")
}

// 多重条件
(score >= 90) ? {
    print("Excellent!")
} : (score >= 70) ? {
    print("Good!")
} : {
    print("Need improvement")
}

// 中文版
（玩家．生命值 》 0）？ {
    打印（"玩家存活"）
}： {
    打印（"玩家死亡"）
}
```

#### 循环语句 `^{}`
```rust
// 英文版
i := 0
^(i < 10) {
    print("Count: " + i)
    i += 1
}

// For-each 循环
players := [player1, player2, player3]
^(player in players) {
    player.update()
}

// 中文版
计数 ：=  0
＾（计数 ＜ 10）{
    打印（"计数： " ＋ 计数）
    计数 ＋＝ 1
}
```

#### 模式匹配 `#{}`
```rust
// 英文版
#{player.state} {
    PlayerState::Idle => {
        print("Player is idle")
    },
    PlayerState::Moving => {
        print("Player is moving")
    },
    PlayerState::Attacking => {
        print("Player is attacking")
    },
    _ => {
        print("Unknown state")
    }
}

// 中文版
＃{玩家．状态} {
    玩家状态：：闲置 ＝》 {
        打印（"玩家空闲"）
    }，
    玩家状态：：移动 ＝》 {
        打印（"玩家移动"）
    }，
    ＿ ＝》 {
        打印（"未知状态"）
    }
}
```

### 10. 三符号赋值系统

```rust
// = 强引用 (默认)
player1 := Player("Alice", 100.0)  // player1拥有对象
player2 := player1                  // player2也强引用同一对象

// ~= 弱引用 (打破循环引用)
? enemy ~= player1                   // enemy弱引用player1，不影响生命周期

// := 值拷贝
? player_copy := player1             // 创建player1的完整副本

// 中文版
玩家1 ：=  玩家（"爱丽丝"， 100.0）
玩家2 ：=  玩家1
？ 敌人 ~= 玩家1
？ 玩家副本 ：＝ 玩家1
```

---

## 🎮 游戏开发示例

### 完整游戏类示例
```rust
// 英文版游戏示例
>> "math"
>> "graphics"

@ GameObject {
    id: i32,
    position: Vector3,
    velocity: Vector3,
    is_active: bool
}

@ Player {
    game_object: GameObject,
    health: f64,
    max_health: f64,
    weapon ~= Weapon,  // 弱引用，避免循环
    inventory: Array<Item>
}

@ Enemy {
    game_object: GameObject,
    health: f64,
    target ~= Player,  // 弱引用玩家
    ai_state: AIState
}

% Updatable {
    update(delta_time: f64) -> void
}

% Drawable {
    draw(renderer: Renderer) -> void
}

& Player {
    Player(name: string, x: f64, y: f64) {
        _.game_object = GameObject {
            id: generate_id(),
            position: Vector3 { x: x, y: y, z: 0.0 },
            velocity: Vector3 { x: 0.0, y: 0.0, z: 0.0 },
            is_active: true
        }
        _.health = 100.0
        _.max_health = 100.0
        _.inventory = Array<Item>()
    }

    update(delta_time: f64) {
        // 更新位置
        _.game_object.position.x += _.game_object.velocity.x * delta_time
        _.game_object.position.y += _.game_object.velocity.y * delta_time

        // 检查边界
        (_.game_object.position.x < 0.0) ? {
            _.game_object.position.x = 0.0
        }
    }

    take_damage(damage: f64) {
        _.health -= damage
        (_.health <= 0.0) ? {
            _.health = 0.0
            _.game_object.is_active = false
            print("Player died!")
        }
    }

    heal(amount: f64) {
        _.health += amount
        (_.health > _.max_health) ? {
            _.health = _.max_health
        }
    }
}

main() {
    player := Player("Hero", 100.0, 100.0)
    enemy := Enemy()
    enemy.target ~= player  // 弱引用设置

    // 游戏循环
    running := true
    ^(running) {
        delta_time := get_delta_time()

        player.update(delta_time)
        enemy.update(delta_time)

        // 碰撞检测
        (check_collision(player, enemy)) ? {
            player.take_damage(10.0)
            enemy.take_damage(5.0)
        }

        // 检查游戏结束
        (!player.game_object.is_active) ? {
            running = false
            print("Game Over!")
        }

        render_frame()
    }

    <- 0
}
```

### 中文版游戏示例
```rust
》》 "数学库"
》》 "图形库"

@ 游戏对象 {
    编号： 整数，
    位置： 三维向量，
    速度： 三维向量，
    是否激活： 布尔
}

@ 玩家 {
    游戏对象： 游戏对象，
    生命值： 浮点数，
    最大生命值： 浮点数，
    武器 ~= 武器，
    背包： 数组＜物品＞
}

& 玩家 {
    玩家（姓名： 字符串， 横坐标： 浮点数， 纵坐标： 浮点数） {
        ＿．游戏对象 ＝ 游戏对象 {
            编号： 生成编号（），
            位置： 三维向量 { 横： 横坐标， 纵： 纵坐标， 高： 0.0 }，
            速度： 三维向量 { 横： 0.0， 纵： 0.0， 高： 0.0 }，
            是否激活： 真
        }
        ＿．生命值 ＝ 100.0
        ＿．最大生命值 ＝ 100.0
    }

    更新（时间间隔： 浮点数） {
        ＿．游戏对象．位置．横 ＋＝ ＿．游戏对象．速度．横 ＊ 时间间隔
        ＿．游戏对象．位置．纵 ＋＝ ＿．游戏对象．速度．纵 ＊ 时间间隔
    }

    受到伤害（伤害值： 浮点数） {
        ＿．生命值 －＝ 伤害值
        （＿．生命值 ＜＝ 0.0）？ {
            ＿．生命值 ＝ 0.0
            ＿．游戏对象．是否激活 ＝ 假
            打印（"玩家死亡！"）
        }
    }
}

主函数（） {
    玩家 ：=  玩家（"英雄"， 100.0， 100.0）

    游戏运行 ：=  真
    ＾（游戏运行）{
        时间间隔 ：=  获取时间间隔（）
        玩家．更新（时间间隔）

        （！玩家．游戏对象．是否激活）？ {
            游戏运行 ＝ 假
            打印（"游戏结束！"）
        }

        渲染帧（）
    }

    《- 0
}
```

---

## 🔧 内存管理规则

### 循环引用避免
```rust
// ❌ 错误：会造成循环引用
@ Player {
    enemy = Enemy  // 强引用
}
@ Enemy {
    target = Player  // 强引用 - 循环！
}

// ✅ 正确：使用弱引用打破循环
@ Player {
    enemy = Enemy  // 强引用
}
@ Enemy {
    target ~= Player  // 弱引用 - 打破循环
}

// ✅ 正确：使用ID引用
@ Player {
    id: i32,
    enemy_id: i32  // 通过ID引用
}
@ Enemy {
    id: i32,
    target_player_id: i32  // 通过ID引用
}
```

### 智能指针使用
```rust
// 自动内存管理
player := Player("Alice", 100.0)  // 创建时自动分配
another_ref := player             // 引用计数+1
// player和another_ref超出作用域时自动释放

// 手动释放（特殊情况）
player.~Player()  // 显式调用析构函数
```

---

## 📋 数据类型

### 基本类型
```rust
// 整数类型
i8, i16, i32, i64     // 有符号整数
u8, u16, u32, u64     // 无符号整数

// 浮点类型
f32, f64              // 32位和64位浮点数

// 其他类型
bool                  // 布尔值：true/false
char                  // 字符
string                // 字符串

// 中文类型名
整数, 长整数           // i32, i64
浮点数, 双精度浮点数    // f32, f64
布尔, 字符, 字符串     // bool, char, string
```

### 复合类型
```rust
// 数组
Array<i32>            // 动态数组
[i32; 10]            // 固定数组

// 元组
(i32, string, f64)   // 元组类型

// 可选类型
Option<Player>       // 可能为空的玩家对象

// 结果类型
Result<i32, string>  // 成功返回i32，失败返回错误信息
```

---

## 🎯 AI编程指导原则

### 1. 符号使用规则
- **模块导入**: 始终使用 `>>` 而非 `import`
- **变量声明**: 使用 `?` 而非 `let`/`var`
- **结构定义**: 使用 `@` 而非 `struct`/`class`
- **方法实现**: 使用 `&` 而非 `impl`
- **返回语句**: 使用 `<-` 而非 `return`

### 2. 内存安全原则
- **避免循环引用**: 使用 `~=` 弱引用或ID引用
- **构造析构**: 使用 `ClassName()` 和 `~ClassName()` 格式
- **智能指针**: 让编译器自动管理内存，避免手动分配

### 3. 中文编程原则
- **一致性**: 同一文件内保持半角或全角符号一致
- **可读性**: 中文标识符应当清晰表达含义
- **标准化**: 遵循中文编程命名规范

### 4. 游戏开发最佳实践
- **组件化设计**: 使用接口和组合而非继承
- **状态管理**: 使用枚举和模式匹配管理游戏状态
- **性能优化**: 合理使用值拷贝 `:=` 和引用 `=`

---

## 🚀 完整项目模板

### 基础项目结构
```
game_project/
├── src/
│   ├── main.pg          // 入口文件
│   ├── player.pg        // 玩家模块
│   ├── enemy.pg         // 敌人模块
│   ├── weapon.pg        // 武器模块
│   └── utils.pg         // 工具函数
├── assets/              // 资源文件
└── README.md           // 项目说明
```

### main.pg 模板
```rust
>> "graphics"
>> "input"
>> "audio"
>> "player"
>> "enemy"
>> "game_manager"

main() {
    // 初始化系统
    init_graphics(800, 600, "My Game")
    init_audio()
    init_input()

    // 创建游戏对象
    game_manager := GameManager()
    game_manager.init()

    // 主游戏循环
    running := true
    ^(running) {
        delta_time := get_delta_time()

        // 处理输入
        process_input()

        // 更新游戏逻辑
        game_manager.update(delta_time)

        // 渲染
        clear_screen()
        game_manager.render()
        present_screen()

        // 检查退出条件
        (should_quit()) ? {
            running = false
        }
    }

    // 清理资源
    game_manager.cleanup()
    cleanup_systems()

    <- 0
}
```

---

## 📚 错误处理

### 常见编译错误
```rust
// ❌ 循环引用错误
编译错误：检测到循环引用
player.pg → enemy.pg → weapon.pg → player.pg

// ❌ 类型不匹配
类型错误：期望 f64，得到 i32
建议：使用 as f64 进行类型转换

// ❌ 变量未初始化
错误：变量 'health' 可能未初始化
建议：在使用前为变量赋值
```

### 运行时错误
```rust
// ❌ 空指针访问
运行时错误：尝试访问空指针
建议：使用 Option<T> 类型处理可能为空的值

// ❌ 数组越界
运行时错误：数组索引超出范围
索引：10，数组长度：5
```

---

## 🔍 测试示例

### 单元测试模板
```rust
>> "testing"

test_player_creation() {
    player := Player("Test", 100.0, 50.0)
    assert_eq(player.health, 100.0)
    assert_eq(player.game_object.position.x, 100.0)
    print("✅ Player creation test passed")
}

test_damage_calculation() {
    player := Player("Test", 100.0, 50.0)
    player.take_damage(25.0)
    assert_eq(player.health, 75.0)
    print("✅ Damage calculation test passed")
}

run_tests() {
    test_player_creation()
    test_damage_calculation()
    print("🎉 All tests passed!")
}
```

---

## 💡 AI写代码时的注意事项

1. **符号优先**: 总是使用polyglot符号，而不是传统关键字
2. **内存安全**: 注意使用`~=`避免循环引用
3. **类型安全**: 明确变量类型，合理使用类型转换
4. **中文模式**: 中文版本必须使用全角符号保持一致性
5. **游戏优化**: 对于游戏开发，优先考虑性能和内存效率
6. **错误处理**: 使用Result类型和Option类型处理错误情况
7. **模块化**: 合理拆分代码到不同模块，避免单文件过大

这份知识集涵盖了polyglot/文达语言的所有核心语法和最佳实践，AI可以据此生成正确、高效、符合规范的polyglot/文达代码。
