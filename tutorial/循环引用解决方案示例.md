# polyglot 循环引用解决方案详解

## 🔴 问题场景：循环引用

### 原始代码结构（有问题）
```
项目结构：
├── player.pg
├── enemy.pg
└── main.pg
```

#### player.pg
```rust
// ❌ 问题代码
import "enemy"

struct Player {
    id: i32,
    health: f32,
    position: Vector3,
    target_enemy: Enemy  // 直接引用Enemy类型
}

func player_attack(player: Player, enemy: Enemy) -> f32 {
    return calculate_damage(player.attack_power, enemy.defense)
}
```

#### enemy.pg
```rust
// ❌ 问题代码
import "player"  // 这里形成了循环：player.pg → enemy.pg → player.pg

struct Enemy {
    id: i32,
    health: f32,
    position: Vector3,
    target_player: Player  // 直接引用Player类型
}

func enemy_attack(enemy: Enemy, player: Player) -> f32 {
    return calculate_damage(enemy.attack_power, player.defense)
}
```

### 依赖图（有问题）
```
player.pg ──────→ enemy.pg
    ↑                 │
    │                 │
    └─────────────────┘

这形成了一个环，编译器无法确定先编译哪个文件！
```

---

## ✅ 解决方案 1：提取公共模块

### 重构后的代码结构
```
项目结构：
├── common.pg        # 新增：公共定义
├── player.pg        # 重构：只依赖common
├── enemy.pg         # 重构：只依赖common
└── main.pg
```

#### common.pg（新建）
```rust
// ✅ 公共定义文件
// 所有共同需要的类型和函数都放在这里

// 基础数据类型
@ Vector3 {
    x: f32,
    y: f32,
    z: f32
}

@ EntityId {
    value: i32
}

// 游戏实体的通用接口
% GameEntity {
    func get_id() -> EntityId
    func get_position() -> Vector3
    func get_health() -> f32
    func take_damage(damage: f32)
}

// 公共的战斗计算函数
func calculate_damage(attack_power: f32, defense: f32) -> f32 {
    let base_damage = attack_power - defense
    if base_damage < 0 {
        return 0.0
    }
    return base_damage
}

// 距离计算
func calculate_distance(pos1: Vector3, pos2: Vector3) -> f32 {
    let dx = pos1.x - pos2.x
    let dy = pos1.y - pos2.y
    let dz = pos1.z - pos2.z
    return sqrt(dx*dx + dy*dy + dz*dz)
}
```

#### player.pg（重构后）
```rust
// ✅ 重构后的player.pg
import "common"  // 只导入common，不导入enemy

struct Player {
    id: EntityId,
    health: f32,
    position: Vector3,
    attack_power: f32,
    defense: f32,
    target_enemy_id: EntityId  // 用ID引用，而不是直接引用Enemy对象
}

// 实现公共接口
impl GameEntity for Player {
    func get_id() -> EntityId {
        return self.id
    }

    func get_position() -> Vector3 {
        return self.position
    }

    func get_health() -> f32 {
        return self.health
    }

    func take_damage(damage: f32) {
        self.health -= damage
        if self.health < 0 {
            self.health = 0
        }
    }
}

// 玩家特有的功能
func player_move_to(player: Player, target: Vector3) {
    player.position = target
}

func player_set_target(player: Player, enemy_id: EntityId) {
    player.target_enemy_id = enemy_id
}
```

#### enemy.pg（重构后）
```rust
// ✅ 重构后的enemy.pg
import "common"  // 只导入common，不导入player

struct Enemy {
    id: EntityId,
    health: f32,
    position: Vector3,
    attack_power: f32,
    defense: f32,
    target_player_id: EntityId  // 用ID引用，而不是直接引用Player对象
}

// 实现公共接口
impl GameEntity for Enemy {
    func get_id() -> EntityId {
        return self.id
    }

    func get_position() -> Vector3 {
        return self.position
    }

    func get_health() -> f32 {
        return self.health
    }

    func take_damage(damage: f32) {
        self.health -= damage
        if self.health < 0 {
            self.health = 0
        }
    }
}

// 敌人特有的功能
func enemy_patrol(enemy: Enemy, waypoints: []Vector3) {
    // 巡逻逻辑
}

func enemy_set_target(enemy: Enemy, player_id: EntityId) {
    enemy.target_player_id = player_id
}
```

#### main.pg（使用示例）
```rust
// ✅ 主程序：协调player和enemy的交互
import "common"
import "player"
import "enemy"

func main() {
    // 创建游戏实体
    let player1 = Player {
        id: EntityId { value: 1 },
        health: 100.0,
        position: Vector3 { x: 0.0, y: 0.0, z: 0.0 },
        attack_power: 25.0,
        defense: 5.0,
        target_enemy_id: EntityId { value: 0 }
    }

    let enemy1 = Enemy {
        id: EntityId { value: 2 },
        health: 80.0,
        position: Vector3 { x: 10.0, y: 0.0, z: 0.0 },
        attack_power: 20.0,
        defense: 3.0,
        target_player_id: EntityId { value: 1 }
    }

    // 计算战斗结果
    let distance = calculate_distance(player1.get_position(), enemy1.get_position())
    if distance < 5.0 {  // 在攻击范围内
        let damage_to_enemy = calculate_damage(player1.attack_power, enemy1.defense)
        enemy1.take_damage(damage_to_enemy)

        let damage_to_player = calculate_damage(enemy1.attack_power, player1.defense)
        player1.take_damage(damage_to_player)
    }
}
```

### 重构后的依赖图（无循环）
```
           common.pg
          ╱         ╲
         ╱           ╲
    player.pg    enemy.pg
         ╲           ╱
          ╲         ╱
           main.pg

这是一个有向无环图(DAG)，编译器可以按以下顺序编译：
1. common.pg
2. player.pg 和 enemy.pg（可以并行编译）
3. main.pg
```

---

## ✅ 解决方案 2：使用接口和工厂模式

### 更高级的解决方案
```rust
// common.pg
interface Combatant {
    func get_attack_power() -> f32
    func get_defense() -> f32
    func take_damage(amount: f32)
    func is_alive() -> bool
}

// 战斗系统（不依赖具体类型）
func combat_round(attacker: Combatant, defender: Combatant) -> bool {
    if !attacker.is_alive() || !defender.is_alive() {
        return false
    }

    let damage = calculate_damage(attacker.get_attack_power(), defender.get_defense())
    defender.take_damage(damage)
    return true
}
```

---

## 🔍 编译器的检测过程

### 编译器如何检测循环引用
```
1. 扫描所有.pg文件，提取import语句
2. 构建模块依赖图：
   player.pg → [enemy.pg]
   enemy.pg → [player.pg]

3. 使用深度优先搜索(DFS)检测环：
   开始访问 player.pg
   → 访问 enemy.pg
   → 尝试访问 player.pg（发现已在访问栈中）
   → 检测到环！

4. 报告错误和解决建议
```

### 编译器的友好错误提示
```
编译错误：检测到循环引用

循环路径：
player.pg → enemy.pg → player.pg

问题分析：
- player.pg 的第3行导入了 enemy.pg
- enemy.pg 的第2行导入了 player.pg
- 这形成了循环依赖，编译器无法确定编译顺序

建议解决方案：
✅ 方案1：提取公共模块
  创建 common.pg 存放 Vector3, EntityId 等共同类型
  让 player.pg 和 enemy.pg 都只导入 common.pg

✅ 方案2：使用ID引用
  用 enemy_id: i32 代替 enemy: Enemy
  在需要时通过游戏系统查找对应对象

✅ 方案3：重新设计架构
  考虑是否真的需要相互引用
  可能存在更好的设计模式

详细文档：https://polyglot-lang.org/docs/circular-dependency
```

这种解决方案的核心思想是：**将相互依赖的部分提取到一个公共模块中，让原本相互依赖的模块都依赖这个公共模块，从而打破循环**