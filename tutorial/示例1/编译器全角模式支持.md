# polyglot ç¼–è¯‘å™¨å…¨è§’æ¨¡å¼æ”¯æŒ

## ğŸ” æ¦‚è¿°

polyglot ç¼–è¯‘å™¨å®Œå…¨æ”¯æŒå…¨è§’ç¬¦å·æ¨¡å¼ï¼Œè¿™æ˜¯ä¸€ä¸ªåˆ›æ–°æ€§çš„ç‰¹æ€§ï¼Œè®©ä¸­æ–‡å¼€å‘è€…èƒ½å¤Ÿä½¿ç”¨ä¸ä¸­æ–‡å­—ç¬¦ç­‰å®½çš„å…¨è§’ç¬¦å·è¿›è¡Œç¼–ç¨‹ï¼Œæä¾›çœŸæ­£çº¯æ­£çš„ä¸­æ–‡ç¼–ç¨‹ä½“éªŒã€‚

## ğŸ¯ è®¾è®¡ç†å¿µ

### æ ¸å¿ƒç›®æ ‡
1. **è§†è§‰ä¸€è‡´æ€§** - å…¨è§’ç¬¦å·ä¸ä¸­æ–‡å­—ç¬¦ç­‰å®½ï¼Œæ’ç‰ˆæ•´é½ç¾è§‚
2. **æ–‡åŒ–é€‚åº”æ€§** - ç¬¦åˆä¸­æ–‡æ’ç‰ˆå’Œè¾“å…¥ä¹ æƒ¯
3. **è¾“å…¥ä¾¿åˆ©æ€§** - ä¸­æ–‡è¾“å…¥æ³•çŠ¶æ€ä¸‹ç›´æ¥è¾“å…¥ç¬¦å·
4. **ä»£ç å¯è¯»æ€§** - åœ¨ä¸­æ–‡ç¯å¢ƒä¸‹æä¾›æœ€ä½³è§†è§‰ä½“éªŒ

### æŠ€æœ¯åŸç†
ç¼–è¯‘å™¨åœ¨è¯æ³•åˆ†æé˜¶æ®µè‡ªåŠ¨è¯†åˆ«å¹¶å¤„ç†å…¨è§’ç¬¦å·ï¼Œå°†å…¶è½¬æ¢ä¸ºç›¸åº”çš„è¯­æ³•tokenï¼Œç¡®ä¿è¯­ä¹‰ä¸åŠè§’ç¬¦å·å®Œå…¨ä¸€è‡´ã€‚

## ğŸ”§ ç¼–è¯‘å™¨æ¶æ„

### è¯æ³•åˆ†æå™¨ï¼ˆLexerï¼‰å¢å¼º

```rust
// è¯æ³•åˆ†æå™¨æ ¸å¿ƒç»“æ„
pub struct FullWidthLexer {
    input: Vec<char>,
    position: usize,
    current_mode: SymbolMode,
    unicode_handler: UnicodeHandler,
}

#[derive(Debug, Clone, PartialEq)]
pub enum SymbolMode {
    HalfWidth,    // åŠè§’æ¨¡å¼
    FullWidth,    // å…¨è§’æ¨¡å¼
    AutoDetect,   // è‡ªåŠ¨æ£€æµ‹æ¨¡å¼
}

impl FullWidthLexer {
    // å…¨è§’ç¬¦å·è¯†åˆ«å’Œè½¬æ¢
    fn recognize_fullwidth_token(&mut self) -> Result<Token, LexError> {
        match self.current_char() {
            'ã€‹' if self.peek_char() == Some('ã€‹') => {
                self.advance(); // æ¶ˆè´¹ç¬¬ä¸€ä¸ªã€‹
                self.advance(); // æ¶ˆè´¹ç¬¬äºŒä¸ªã€‹
                Ok(Token::Output)
            },
            'ï¼Ÿ' => {
                self.advance();
                Ok(Token::Question)
            },
            'ï¼œ' if self.peek_char() == Some('ï¼') => {
                self.advance(); // æ¶ˆè´¹ï¼œ
                self.advance(); // æ¶ˆè´¹ï¼
                Ok(Token::LeftArrow)
            },
            // ... æ›´å¤šå…¨è§’ç¬¦å·å¤„ç†
            _ => self.handle_unknown_fullwidth_char()
        }
    }
}
```

### ç¬¦å·æ˜ å°„è¡¨

```rust
// å…¨è§’ç¬¦å·åˆ°åŠè§’ç¬¦å·çš„æ˜ å°„
pub const FULLWIDTH_SYMBOL_MAP: &[(&str, &str)] = &[
    ("ã€‹ã€‹", ">>"),        // è¾“å‡ºç¬¦å·
    ("ï¼Ÿ", "?"),           // å˜é‡å£°æ˜
    ("ï¼œï¼", "<-"),        // è¿”å›å€¼
    ("ï¼ã€‹", "->"),        // å‡½æ•°è¿”å›ç±»å‹
    ("ï¼ ", "@"),           // ç»“æ„å®šä¹‰
    ("ï¼†", "&"),           // å®ç°å—
    ("ï¼…", "%"),           // æ¥å£å®šä¹‰
    ("ï¼ƒ", "#"),           // æšä¸¾å®šä¹‰
    ("ï¼Š", "*"),           // å¸¸é‡å®šä¹‰
    ("ï¼¾", "^"),           // å¾ªç¯
    ("ï½", "~"),           // ææ„å‡½æ•°
    ("ï¼¿", "_"),           // ä¸‹åˆ’çº¿self
    ("ï¼", "="),           // èµ‹å€¼
    ("ï¼‹", "+"),           // åŠ æ³•
    ("ï¼", "-"),           // å‡æ³•
    ("ï¼", "/"),           // é™¤æ³•
    ("ï¼…", "%"),           // å–æ¨¡
    ("ï¼Šï¼Š", "**"),        // å¹‚è¿ç®—
    ("ï¼ï¼", "=="),        // ç­‰äº
    ("ï¼ï¼", "!="),        // ä¸ç­‰äº
    ("ï¼œ", "<"),           // å°äº
    ("ï¼", ">"),           // å¤§äº
    ("ï¼œï¼", "<="),        // å°äºç­‰äº
    ("ã€‹ï¼", ">="),        // å¤§äºç­‰äº
    ("ï¼†ï¼†", "&&"),        // é€»è¾‘ä¸
    ("ï½œï½œ", "||"),        // é€»è¾‘æˆ–
    ("ï¼", "!"),           // é€»è¾‘é
    ("ï½›", "{"),           // å·¦èŠ±æ‹¬å·
    ("ï½", "}"),           // å³èŠ±æ‹¬å·
    ("ï¼ˆ", "("),           // å·¦åœ†æ‹¬å·
    ("ï¼‰", ")"),           // å³åœ†æ‹¬å·
    ("ï¼»", "["),           // å·¦æ–¹æ‹¬å·
    ("ï¼½", "]"),           // å³æ–¹æ‹¬å·
    ("ï¼š", ":"),           // å†’å·
    ("ï¼›", ";"),           // åˆ†å·
    ("ï¼Œ", ","),           // é€—å·
    (""", "\""),          // å…¨è§’åŒå¼•å·
    ("'", "'"),           // å…¨è§’å•å¼•å·
    ("ï¼", "."),           // å…¨è§’å¥å·
];

// Unicode èŒƒå›´å®šä¹‰
pub const FULLWIDTH_RANGES: &[(u32, u32)] = &[
    (0xFF01, 0xFF5E),   // å…¨è§’ASCIIç¬¦å·
    (0x3000, 0x303F),   // CJKç¬¦å·å’Œæ ‡ç‚¹
    (0x3040, 0x309F),   // å¹³å‡å
    (0x30A0, 0x30FF),   // ç‰‡å‡å
    (0x4E00, 0x9FAF),   // CJKç»Ÿä¸€æ±‰å­—
];
```

## ğŸ”„ ç¼–è¯‘æµç¨‹

### 1. æ¨¡å¼æ£€æµ‹é˜¶æ®µ

```rust
impl ModeDetector {
    pub fn detect_mode(source: &str) -> SymbolMode {
        let mut fullwidth_count = 0;
        let mut halfwidth_count = 0;

        // æ‰«æå‰100ä¸ªtokenæ¥ç¡®å®šæ¨¡å¼
        for token in source.chars().take(1000) {
            if is_fullwidth_symbol(token) {
                fullwidth_count += 1;
            } else if is_halfwidth_symbol(token) {
                halfwidth_count += 1;
            }
        }

        match (fullwidth_count, halfwidth_count) {
            (f, h) if f > 0 && h == 0 => SymbolMode::FullWidth,
            (f, h) if f == 0 && h > 0 => SymbolMode::HalfWidth,
            (f, h) if f > h => SymbolMode::FullWidth,
            (f, h) if h > f => SymbolMode::HalfWidth,
            _ => SymbolMode::AutoDetect,
        }
    }
}
```

### 2. è¯æ³•åˆ†æé˜¶æ®µ

```rust
impl Compiler {
    pub fn tokenize(&mut self, source: &str) -> Result<Vec<Token>, CompileError> {
        // 1. æ£€æµ‹ç¬¦å·æ¨¡å¼
        let mode = ModeDetector::detect_mode(source);

        // 2. åˆå§‹åŒ–è¯æ³•åˆ†æå™¨
        let mut lexer = match mode {
            SymbolMode::FullWidth => FullWidthLexer::new(source),
            SymbolMode::HalfWidth => HalfWidthLexer::new(source),
            SymbolMode::AutoDetect => AutoDetectLexer::new(source),
        };

        // 3. è¿›è¡Œè¯æ³•åˆ†æ
        let mut tokens = Vec::new();
        while !lexer.is_at_end() {
            match lexer.next_token() {
                Ok(token) => tokens.push(token),
                Err(e) => return Err(CompileError::LexError(e)),
            }
        }

        // 4. éªŒè¯ç¬¦å·ä¸€è‡´æ€§
        self.validate_symbol_consistency(&tokens)?;

        Ok(tokens)
    }
}
```

### 3. è¯­æ³•åˆ†æé˜¶æ®µ

```rust
// è¯­æ³•åˆ†æå™¨å¯¹å…¨è§’å’ŒåŠè§’ç¬¦å·é€æ˜å¤„ç†
impl Parser {
    pub fn parse(&mut self, tokens: Vec<Token>) -> Result<AST, ParseError> {
        // Tokenå·²ç»æ ‡å‡†åŒ–ï¼Œè¯­æ³•åˆ†æå™¨æ— éœ€å…³å¿ƒåŸå§‹ç¬¦å·ç±»å‹
        self.parse_program(tokens)
    }

    fn parse_output_statement(&mut self) -> Result<OutputNode, ParseError> {
        // æ— è®ºæ˜¯ >> è¿˜æ˜¯ ã€‹ã€‹ï¼Œéƒ½è§£æä¸ºç›¸åŒçš„è¾“å‡ºè¯­å¥
        self.expect_token(Token::Output)?;
        let expr = self.parse_expression()?;
        Ok(OutputNode::new(expr))
    }
}
```

## ğŸ› ï¸ ç¼–è¯‘å™¨å·¥å…·

### 1. æ¨¡å¼æ£€æµ‹å·¥å…·

```bash
# åŸºæœ¬æ¨¡å¼æ£€æµ‹
polyglot check-mode example.pg
```

```rust
// å®ç°ç¤ºä¾‹
pub fn check_mode_command(filename: &str) -> Result<(), CliError> {
    let source = fs::read_to_string(filename)?;
    let mode = ModeDetector::detect_mode(&source);
    let stats = ModeDetector::analyze_symbols(&source);

    println!("æ–‡ä»¶ï¼š{}", filename);
    println!("æ¨¡å¼ï¼š{}", mode_to_chinese(&mode));
    println!("ç¬¦å·ç»Ÿè®¡ï¼š");
    println!("  - å…¨è§’ç¬¦å·ï¼š{} ä¸ª", stats.fullwidth_count);
    println!("  - åŠè§’ç¬¦å·ï¼š{} ä¸ª", stats.halfwidth_count);
    println!("  - ä¸€è‡´æ€§ï¼š{}", if stats.is_consistent { "âœ“ é€šè¿‡" } else { "âœ— ä¸ä¸€è‡´" });

    if !stats.is_consistent {
        println!("\nä¸ä¸€è‡´çš„ç¬¦å·ï¼š");
        for issue in stats.inconsistent_symbols {
            println!("  è¡Œ {}: {} (æœŸæœ›: {})", issue.line, issue.found, issue.expected);
        }
    }

    Ok(())
}
```

### 2. ç¬¦å·è½¬æ¢å·¥å…·

```bash
# è½¬æ¢ä¸ºå…¨è§’æ¨¡å¼
polyglot convert --to-fullwidth input.pg [output.pg]

# è½¬æ¢ä¸ºåŠè§’æ¨¡å¼
polyglot convert --to-halfwidth input.pg [output.pg]
```

```rust
pub fn convert_symbols(
    input: &str,
    from_mode: SymbolMode,
    to_mode: SymbolMode
) -> Result<String, ConversionError> {
    let mut result = String::new();
    let chars: Vec<char> = input.chars().collect();
    let mut i = 0;

    while i < chars.len() {
        match (from_mode, to_mode) {
            (SymbolMode::HalfWidth, SymbolMode::FullWidth) => {
                if let Some(converted) = convert_to_fullwidth(&chars, &mut i) {
                    result.push_str(&converted);
                } else {
                    result.push(chars[i]);
                    i += 1;
                }
            },
            (SymbolMode::FullWidth, SymbolMode::HalfWidth) => {
                if let Some(converted) = convert_to_halfwidth(&chars, &mut i) {
                    result.push_str(&converted);
                } else {
                    result.push(chars[i]);
                    i += 1;
                }
            },
            _ => {
                result.push(chars[i]);
                i += 1;
            }
        }
    }

    Ok(result)
}
```

### 3. æ‰¹é‡éªŒè¯å·¥å…·

```bash
# éªŒè¯é¡¹ç›®ä¸­æ‰€æœ‰æ–‡ä»¶çš„ç¬¦å·ä¸€è‡´æ€§
polyglot validate-mode --recursive src/
```

```rust
pub fn validate_project(project_path: &Path) -> Result<ValidationReport, IoError> {
    let mut report = ValidationReport::new();

    for entry in WalkDir::new(project_path) {
        let entry = entry?;
        if entry.path().extension() == Some(OsStr::new("pg")) {
            let file_path = entry.path();
            let source = fs::read_to_string(file_path)?;

            match ModeDetector::validate_consistency(&source) {
                Ok(_) => report.add_success(file_path),
                Err(issues) => report.add_failure(file_path, issues),
            }
        }
    }

    Ok(report)
}
```

## ğŸ›ï¸ ç¼–è¯‘å™¨é…ç½®

### 1. é¡¹ç›®é…ç½®æ–‡ä»¶

```toml
# .polyglot é¡¹ç›®é…ç½®æ–‡ä»¶
[compiler]
symbol_mode = "fullwidth"  # "halfwidth" | "fullwidth" | "auto"
strict_mode = true         # æ˜¯å¦ä¸¥æ ¼æ£€æŸ¥ç¬¦å·ä¸€è‡´æ€§
auto_convert = false       # æ˜¯å¦è‡ªåŠ¨è½¬æ¢ç¬¦å·

[fullwidth]
preferred_quotes = "fullwidth"  # "fullwidth" | "corner_brackets"
tab_size = 4
indent_style = "spaces"

[error_reporting]
show_unicode_info = true   # é”™è¯¯ä¿¡æ¯ä¸­æ˜¾ç¤ºUnicodeä¿¡æ¯
suggest_conversion = true  # å»ºè®®ç¬¦å·è½¬æ¢
```

### 2. ç¼–è¯‘å™¨å‘½ä»¤è¡Œé€‰é¡¹

```bash
# æŒ‡å®šç¬¦å·æ¨¡å¼ç¼–è¯‘
polyglot build --symbol-mode fullwidth main.pg

# ä¸¥æ ¼æ¨¡å¼ç¼–è¯‘
polyglot build --strict-symbols main.pg

# è‡ªåŠ¨è½¬æ¢å¹¶ç¼–è¯‘
polyglot build --auto-convert --to-fullwidth main.pg
```

## ğŸš¨ é”™è¯¯å¤„ç†

### 1. ç¬¦å·æ¨¡å¼ä¸ä¸€è‡´é”™è¯¯

```rust
#[derive(Debug)]
pub struct SymbolModeError {
    pub file_path: String,
    pub line: usize,
    pub column: usize,
    pub found_symbol: String,
    pub expected_mode: SymbolMode,
    pub found_mode: SymbolMode,
    pub suggestion: String,
}

impl Display for SymbolModeError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f,
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\
             polyglot ç¼–è¯‘å™¨é”™è¯¯æŠ¥å‘Š\n\
             â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n\
             é”™è¯¯ç±»å‹ï¼šç¬¦å·æ¨¡å¼ä¸ä¸€è‡´\n\
             æ–‡ä»¶è·¯å¾„ï¼š{}\n\
             é”™è¯¯ä½ç½®ï¼šç¬¬ {} è¡Œï¼Œç¬¬ {} åˆ—\n\n\
             è¯¦ç»†ä¿¡æ¯ï¼š\n\
               æ£€æµ‹åˆ° {} ç¬¦å· '{}'ï¼Œä½†æ–‡ä»¶å·²ç¡®å®šä¸º {} æ¨¡å¼\n\n\
             ä¿®å¤å»ºè®®ï¼š\n\
               {}\n\n\
             è½¬æ¢å‘½ä»¤ï¼š\n\
               polyglot convert --to-{} {}\n\
             â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            self.file_path,
            self.line,
            self.column,
            mode_to_chinese(&self.found_mode),
            self.found_symbol,
            mode_to_chinese(&self.expected_mode),
            self.suggestion,
            mode_to_english(&self.expected_mode),
            self.file_path
        )
    }
}
```

### 2. Unicode å¤„ç†é”™è¯¯

```rust
pub fn handle_unicode_error(ch: char, position: Position) -> CompileError {
    CompileError::UnicodeError(UnicodeError {
        character: ch,
        unicode_point: ch as u32,
        position,
        suggestion: suggest_similar_symbol(ch),
        message: format!(
            "æ— æ³•è¯†åˆ«çš„Unicodeå­—ç¬¦ '{}' (U+{:04X})",
            ch, ch as u32
        ),
    })
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. ç¬¦å·é¢„å¤„ç†ç¼“å­˜

```rust
pub struct SymbolCache {
    fullwidth_map: HashMap<String, Token>,
    halfwidth_map: HashMap<String, Token>,
    mode_detection_cache: LruCache<String, SymbolMode>,
}

impl SymbolCache {
    pub fn get_token(&self, symbol: &str, mode: SymbolMode) -> Option<Token> {
        match mode {
            SymbolMode::FullWidth => self.fullwidth_map.get(symbol).cloned(),
            SymbolMode::HalfWidth => self.halfwidth_map.get(symbol).cloned(),
            _ => None,
        }
    }
}
```

### 2. å¢é‡ç¼–è¯‘æ”¯æŒ

```rust
pub struct IncrementalCompiler {
    symbol_mode_cache: HashMap<PathBuf, SymbolMode>,
    file_hash_cache: HashMap<PathBuf, u64>,
}

impl IncrementalCompiler {
    pub fn compile_if_changed(&mut self, file_path: &Path) -> Result<bool, CompileError> {
        let current_hash = calculate_file_hash(file_path)?;

        if let Some(&cached_hash) = self.file_hash_cache.get(file_path) {
            if current_hash == cached_hash {
                return Ok(false); // æ–‡ä»¶æœªæ›´æ”¹ï¼Œè·³è¿‡ç¼–è¯‘
            }
        }

        // æ–‡ä»¶å·²æ›´æ”¹ï¼Œé‡æ–°ç¼–è¯‘
        self.compile_file(file_path)?;
        self.file_hash_cache.insert(file_path.to_path_buf(), current_hash);

        Ok(true)
    }
}
```

## ğŸ”® æœªæ¥æ‰©å±•

### 1. æ›´å¤šç¬¦å·æ¨¡å¼æ”¯æŒ

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum SymbolMode {
    HalfWidth,           // åŠè§’ç¬¦å·
    FullWidth,           // å…¨è§’ç¬¦å·
    TraditionalChinese,  // ç¹ä½“ä¸­æ–‡ç¬¦å·
    SimplifiedChinese,   // ç®€ä½“ä¸­æ–‡ç¬¦å·
    Japanese,            // æ—¥æ–‡ç¬¦å·
    Korean,              // éŸ©æ–‡ç¬¦å·
    Mixed,               // æ··åˆæ¨¡å¼ï¼ˆé«˜çº§ç”¨æ³•ï¼‰
}
```

### 2. æ™ºèƒ½ç¬¦å·å»ºè®®

```rust
pub fn suggest_symbol_completion(
    context: &CompletionContext,
    mode: SymbolMode
) -> Vec<SymbolSuggestion> {
    let mut suggestions = Vec::new();

    match mode {
        SymbolMode::FullWidth => {
            suggestions.extend(FULLWIDTH_SYMBOLS.iter().map(|s|
                SymbolSuggestion::new(s.symbol, s.description)
            ));
        },
        _ => {
            suggestions.extend(HALFWIDTH_SYMBOLS.iter().map(|s|
                SymbolSuggestion::new(s.symbol, s.description)
            ));
        }
    }

    suggestions
}
```

## ğŸŒŸ æ€»ç»“

polyglot ç¼–è¯‘å™¨çš„å…¨è§’æ¨¡å¼æ”¯æŒæ˜¯ä¸€ä¸ªçªç ´æ€§çš„ç‰¹æ€§ï¼Œå®ƒï¼š

1. **æŠ€æœ¯åˆ›æ–°** - é¦–æ¬¡åœ¨ç¼–ç¨‹è¯­è¨€ä¸­å®Œæ•´æ”¯æŒå…¨è§’ç¬¦å·
2. **æ–‡åŒ–é€‚åº”** - çœŸæ­£é€‚åº”ä¸­æ–‡ç¼–ç¨‹ç¯å¢ƒ
3. **å·¥ç¨‹åŒ–** - æä¾›å®Œæ•´çš„å·¥å…·é“¾æ”¯æŒ
4. **æ€§èƒ½ä¼˜ç§€** - å¯¹ç¼–è¯‘æ€§èƒ½å½±å“å¾®ä¹å…¶å¾®
5. **æ˜“äºä½¿ç”¨** - è‡ªåŠ¨æ£€æµ‹å’Œè½¬æ¢ï¼Œé™ä½ä½¿ç”¨é—¨æ§›

è¿™ä¸€ç‰¹æ€§è®© polyglot æˆä¸ºçœŸæ­£æ„ä¹‰ä¸Šçš„"å›½é™…åŒ–ç¼–ç¨‹è¯­è¨€"ï¼Œä¸ä»…æ”¯æŒå¤šç§ç¼–ç¨‹èŒƒå¼ï¼Œæ›´æ”¯æŒå¤šç§æ–‡åŒ–èƒŒæ™¯ä¸‹çš„ç¼–ç¨‹ä¹ æƒ¯ï¼