# polyglot 编译器全角模式支持

## 🔍 概述

polyglot 编译器完全支持全角符号模式，这是一个创新性的特性，让中文开发者能够使用与中文字符等宽的全角符号进行编程，提供真正纯正的中文编程体验。

## 🎯 设计理念

### 核心目标
1. **视觉一致性** - 全角符号与中文字符等宽，排版整齐美观
2. **文化适应性** - 符合中文排版和输入习惯
3. **输入便利性** - 中文输入法状态下直接输入符号
4. **代码可读性** - 在中文环境下提供最佳视觉体验

### 技术原理
编译器在词法分析阶段自动识别并处理全角符号，将其转换为相应的语法token，确保语义与半角符号完全一致。

## 🔧 编译器架构

### 词法分析器（Lexer）增强

```rust
// 词法分析器核心结构
pub struct FullWidthLexer {
    input: Vec<char>,
    position: usize,
    current_mode: SymbolMode,
    unicode_handler: UnicodeHandler,
}

#[derive(Debug, Clone, PartialEq)]
pub enum SymbolMode {
    HalfWidth,    // 半角模式
    FullWidth,    // 全角模式
    AutoDetect,   // 自动检测模式
}

impl FullWidthLexer {
    // 全角符号识别和转换
    fn recognize_fullwidth_token(&mut self) -> Result<Token, LexError> {
        match self.current_char() {
            '》' if self.peek_char() == Some('》') => {
                self.advance(); // 消费第一个》
                self.advance(); // 消费第二个》
                Ok(Token::Output)
            },
            '？' => {
                self.advance();
                Ok(Token::Question)
            },
            '＜' if self.peek_char() == Some('－') => {
                self.advance(); // 消费＜
                self.advance(); // 消费－
                Ok(Token::LeftArrow)
            },
            // ... 更多全角符号处理
            _ => self.handle_unknown_fullwidth_char()
        }
    }
}
```

### 符号映射表

```rust
// 全角符号到半角符号的映射
pub const FULLWIDTH_SYMBOL_MAP: &[(&str, &str)] = &[
    ("》》", ">>"),        // 输出符号
    ("？", "?"),           // 变量声明
    ("＜－", "<-"),        // 返回值
    ("－》", "->"),        // 函数返回类型
    ("＠", "@"),           // 结构定义
    ("＆", "&"),           // 实现块
    ("％", "%"),           // 接口定义
    ("＃", "#"),           // 枚举定义
    ("＊", "*"),           // 常量定义
    ("＾", "^"),           // 循环
    ("～", "~"),           // 析构函数
    ("＿", "_"),           // 下划线self
    ("＝", "="),           // 赋值
    ("＋", "+"),           // 加法
    ("－", "-"),           // 减法
    ("／", "/"),           // 除法
    ("％", "%"),           // 取模
    ("＊＊", "**"),        // 幂运算
    ("＝＝", "=="),        // 等于
    ("！＝", "!="),        // 不等于
    ("＜", "<"),           // 小于
    ("＞", ">"),           // 大于
    ("＜＝", "<="),        // 小于等于
    ("》＝", ">="),        // 大于等于
    ("＆＆", "&&"),        // 逻辑与
    ("｜｜", "||"),        // 逻辑或
    ("！", "!"),           // 逻辑非
    ("｛", "{"),           // 左花括号
    ("｝", "}"),           // 右花括号
    ("（", "("),           // 左圆括号
    ("）", ")"),           // 右圆括号
    ("［", "["),           // 左方括号
    ("］", "]"),           // 右方括号
    ("：", ":"),           // 冒号
    ("；", ";"),           // 分号
    ("，", ","),           // 逗号
    (""", "\""),          // 全角双引号
    ("'", "'"),           // 全角单引号
    ("．", "."),           // 全角句号
];

// Unicode 范围定义
pub const FULLWIDTH_RANGES: &[(u32, u32)] = &[
    (0xFF01, 0xFF5E),   // 全角ASCII符号
    (0x3000, 0x303F),   // CJK符号和标点
    (0x3040, 0x309F),   // 平假名
    (0x30A0, 0x30FF),   // 片假名
    (0x4E00, 0x9FAF),   // CJK统一汉字
];
```

## 🔄 编译流程

### 1. 模式检测阶段

```rust
impl ModeDetector {
    pub fn detect_mode(source: &str) -> SymbolMode {
        let mut fullwidth_count = 0;
        let mut halfwidth_count = 0;

        // 扫描前100个token来确定模式
        for token in source.chars().take(1000) {
            if is_fullwidth_symbol(token) {
                fullwidth_count += 1;
            } else if is_halfwidth_symbol(token) {
                halfwidth_count += 1;
            }
        }

        match (fullwidth_count, halfwidth_count) {
            (f, h) if f > 0 && h == 0 => SymbolMode::FullWidth,
            (f, h) if f == 0 && h > 0 => SymbolMode::HalfWidth,
            (f, h) if f > h => SymbolMode::FullWidth,
            (f, h) if h > f => SymbolMode::HalfWidth,
            _ => SymbolMode::AutoDetect,
        }
    }
}
```

### 2. 词法分析阶段

```rust
impl Compiler {
    pub fn tokenize(&mut self, source: &str) -> Result<Vec<Token>, CompileError> {
        // 1. 检测符号模式
        let mode = ModeDetector::detect_mode(source);

        // 2. 初始化词法分析器
        let mut lexer = match mode {
            SymbolMode::FullWidth => FullWidthLexer::new(source),
            SymbolMode::HalfWidth => HalfWidthLexer::new(source),
            SymbolMode::AutoDetect => AutoDetectLexer::new(source),
        };

        // 3. 进行词法分析
        let mut tokens = Vec::new();
        while !lexer.is_at_end() {
            match lexer.next_token() {
                Ok(token) => tokens.push(token),
                Err(e) => return Err(CompileError::LexError(e)),
            }
        }

        // 4. 验证符号一致性
        self.validate_symbol_consistency(&tokens)?;

        Ok(tokens)
    }
}
```

### 3. 语法分析阶段

```rust
// 语法分析器对全角和半角符号透明处理
impl Parser {
    pub fn parse(&mut self, tokens: Vec<Token>) -> Result<AST, ParseError> {
        // Token已经标准化，语法分析器无需关心原始符号类型
        self.parse_program(tokens)
    }

    fn parse_output_statement(&mut self) -> Result<OutputNode, ParseError> {
        // 无论是 >> 还是 》》，都解析为相同的输出语句
        self.expect_token(Token::Output)?;
        let expr = self.parse_expression()?;
        Ok(OutputNode::new(expr))
    }
}
```

## 🛠️ 编译器工具

### 1. 模式检测工具

```bash
# 基本模式检测
polyglot check-mode example.pg
```

```rust
// 实现示例
pub fn check_mode_command(filename: &str) -> Result<(), CliError> {
    let source = fs::read_to_string(filename)?;
    let mode = ModeDetector::detect_mode(&source);
    let stats = ModeDetector::analyze_symbols(&source);

    println!("文件：{}", filename);
    println!("模式：{}", mode_to_chinese(&mode));
    println!("符号统计：");
    println!("  - 全角符号：{} 个", stats.fullwidth_count);
    println!("  - 半角符号：{} 个", stats.halfwidth_count);
    println!("  - 一致性：{}", if stats.is_consistent { "✓ 通过" } else { "✗ 不一致" });

    if !stats.is_consistent {
        println!("\n不一致的符号：");
        for issue in stats.inconsistent_symbols {
            println!("  行 {}: {} (期望: {})", issue.line, issue.found, issue.expected);
        }
    }

    Ok(())
}
```

### 2. 符号转换工具

```bash
# 转换为全角模式
polyglot convert --to-fullwidth input.pg [output.pg]

# 转换为半角模式
polyglot convert --to-halfwidth input.pg [output.pg]
```

```rust
pub fn convert_symbols(
    input: &str,
    from_mode: SymbolMode,
    to_mode: SymbolMode
) -> Result<String, ConversionError> {
    let mut result = String::new();
    let chars: Vec<char> = input.chars().collect();
    let mut i = 0;

    while i < chars.len() {
        match (from_mode, to_mode) {
            (SymbolMode::HalfWidth, SymbolMode::FullWidth) => {
                if let Some(converted) = convert_to_fullwidth(&chars, &mut i) {
                    result.push_str(&converted);
                } else {
                    result.push(chars[i]);
                    i += 1;
                }
            },
            (SymbolMode::FullWidth, SymbolMode::HalfWidth) => {
                if let Some(converted) = convert_to_halfwidth(&chars, &mut i) {
                    result.push_str(&converted);
                } else {
                    result.push(chars[i]);
                    i += 1;
                }
            },
            _ => {
                result.push(chars[i]);
                i += 1;
            }
        }
    }

    Ok(result)
}
```

### 3. 批量验证工具

```bash
# 验证项目中所有文件的符号一致性
polyglot validate-mode --recursive src/
```

```rust
pub fn validate_project(project_path: &Path) -> Result<ValidationReport, IoError> {
    let mut report = ValidationReport::new();

    for entry in WalkDir::new(project_path) {
        let entry = entry?;
        if entry.path().extension() == Some(OsStr::new("pg")) {
            let file_path = entry.path();
            let source = fs::read_to_string(file_path)?;

            match ModeDetector::validate_consistency(&source) {
                Ok(_) => report.add_success(file_path),
                Err(issues) => report.add_failure(file_path, issues),
            }
        }
    }

    Ok(report)
}
```

## 🎛️ 编译器配置

### 1. 项目配置文件

```toml
# .polyglot 项目配置文件
[compiler]
symbol_mode = "fullwidth"  # "halfwidth" | "fullwidth" | "auto"
strict_mode = true         # 是否严格检查符号一致性
auto_convert = false       # 是否自动转换符号

[fullwidth]
preferred_quotes = "fullwidth"  # "fullwidth" | "corner_brackets"
tab_size = 4
indent_style = "spaces"

[error_reporting]
show_unicode_info = true   # 错误信息中显示Unicode信息
suggest_conversion = true  # 建议符号转换
```

### 2. 编译器命令行选项

```bash
# 指定符号模式编译
polyglot build --symbol-mode fullwidth main.pg

# 严格模式编译
polyglot build --strict-symbols main.pg

# 自动转换并编译
polyglot build --auto-convert --to-fullwidth main.pg
```

## 🚨 错误处理

### 1. 符号模式不一致错误

```rust
#[derive(Debug)]
pub struct SymbolModeError {
    pub file_path: String,
    pub line: usize,
    pub column: usize,
    pub found_symbol: String,
    pub expected_mode: SymbolMode,
    pub found_mode: SymbolMode,
    pub suggestion: String,
}

impl Display for SymbolModeError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f,
            "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\
             polyglot 编译器错误报告\n\
             ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n\
             错误类型：符号模式不一致\n\
             文件路径：{}\n\
             错误位置：第 {} 行，第 {} 列\n\n\
             详细信息：\n\
               检测到 {} 符号 '{}'，但文件已确定为 {} 模式\n\n\
             修复建议：\n\
               {}\n\n\
             转换命令：\n\
               polyglot convert --to-{} {}\n\
             ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
            self.file_path,
            self.line,
            self.column,
            mode_to_chinese(&self.found_mode),
            self.found_symbol,
            mode_to_chinese(&self.expected_mode),
            self.suggestion,
            mode_to_english(&self.expected_mode),
            self.file_path
        )
    }
}
```

### 2. Unicode 处理错误

```rust
pub fn handle_unicode_error(ch: char, position: Position) -> CompileError {
    CompileError::UnicodeError(UnicodeError {
        character: ch,
        unicode_point: ch as u32,
        position,
        suggestion: suggest_similar_symbol(ch),
        message: format!(
            "无法识别的Unicode字符 '{}' (U+{:04X})",
            ch, ch as u32
        ),
    })
}
```

## 📊 性能优化

### 1. 符号预处理缓存

```rust
pub struct SymbolCache {
    fullwidth_map: HashMap<String, Token>,
    halfwidth_map: HashMap<String, Token>,
    mode_detection_cache: LruCache<String, SymbolMode>,
}

impl SymbolCache {
    pub fn get_token(&self, symbol: &str, mode: SymbolMode) -> Option<Token> {
        match mode {
            SymbolMode::FullWidth => self.fullwidth_map.get(symbol).cloned(),
            SymbolMode::HalfWidth => self.halfwidth_map.get(symbol).cloned(),
            _ => None,
        }
    }
}
```

### 2. 增量编译支持

```rust
pub struct IncrementalCompiler {
    symbol_mode_cache: HashMap<PathBuf, SymbolMode>,
    file_hash_cache: HashMap<PathBuf, u64>,
}

impl IncrementalCompiler {
    pub fn compile_if_changed(&mut self, file_path: &Path) -> Result<bool, CompileError> {
        let current_hash = calculate_file_hash(file_path)?;

        if let Some(&cached_hash) = self.file_hash_cache.get(file_path) {
            if current_hash == cached_hash {
                return Ok(false); // 文件未更改，跳过编译
            }
        }

        // 文件已更改，重新编译
        self.compile_file(file_path)?;
        self.file_hash_cache.insert(file_path.to_path_buf(), current_hash);

        Ok(true)
    }
}
```

## 🔮 未来扩展

### 1. 更多符号模式支持

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum SymbolMode {
    HalfWidth,           // 半角符号
    FullWidth,           // 全角符号
    TraditionalChinese,  // 繁体中文符号
    SimplifiedChinese,   // 简体中文符号
    Japanese,            // 日文符号
    Korean,              // 韩文符号
    Mixed,               // 混合模式（高级用法）
}
```

### 2. 智能符号建议

```rust
pub fn suggest_symbol_completion(
    context: &CompletionContext,
    mode: SymbolMode
) -> Vec<SymbolSuggestion> {
    let mut suggestions = Vec::new();

    match mode {
        SymbolMode::FullWidth => {
            suggestions.extend(FULLWIDTH_SYMBOLS.iter().map(|s|
                SymbolSuggestion::new(s.symbol, s.description)
            ));
        },
        _ => {
            suggestions.extend(HALFWIDTH_SYMBOLS.iter().map(|s|
                SymbolSuggestion::new(s.symbol, s.description)
            ));
        }
    }

    suggestions
}
```

## 🌟 总结

polyglot 编译器的全角模式支持是一个突破性的特性，它：

1. **技术创新** - 首次在编程语言中完整支持全角符号
2. **文化适应** - 真正适应中文编程环境
3. **工程化** - 提供完整的工具链支持
4. **性能优秀** - 对编译性能影响微乎其微
5. **易于使用** - 自动检测和转换，降低使用门槛

这一特性让 polyglot 成为真正意义上的"国际化编程语言"，不仅支持多种编程范式，更支持多种文化背景下的编程习惯！