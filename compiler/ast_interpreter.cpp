#include "ast_interpreter.h"
#include <iostream>
#include <fstream>
#include <typeinfo>
#include <sstream>

namespace polyglot {

// ASTËß£ÈáäÂô®ÂÆûÁé∞
ASTValue ASTInterpreter::interpret(std::unique_ptr<Program>& program) {
    ASTValue result;

    std::cout << "üöÄ ÂºÄÂßãËß£ÈáäÊâßË°åAST..." << std::endl;

    for (auto& stmt : program->statements) {
        result = visit(stmt.get());
    }

    std::cout << "‚úÖ ASTËß£ÈáäÊâßË°åÂÆåÊàê" << std::endl;
    return result;
}

ASTValue ASTInterpreter::visit(ASTNode* node) {
    // ‰ΩøÁî®dynamic_castËøõË°åÁ±ªÂûãÂà§Êñ≠
    if (auto import = dynamic_cast<ImportDecl*>(node)) {
        return visitImport(import);
    } else if (auto varDecl = dynamic_cast<VariableDecl*>(node)) {
        return visitVariableDecl(varDecl);
    } else if (auto funcDecl = dynamic_cast<FunctionDecl*>(node)) {
        return visitFunctionDecl(funcDecl);
    } else if (auto structDecl = dynamic_cast<StructDecl*>(node)) {
        return visitStructDecl(structDecl);
    } else if (auto block = dynamic_cast<Block*>(node)) {
        return visitBlock(block);
    } else if (auto returnStmt = dynamic_cast<ReturnStmt*>(node)) {
        return visitReturnStmt(returnStmt);
    } else if (auto exprStmt = dynamic_cast<ExpressionStmt*>(node)) {
        return visitExpressionStmt(exprStmt);
    } else if (auto identifier = dynamic_cast<Identifier*>(node)) {
        return visitIdentifier(identifier);
    } else if (auto literal = dynamic_cast<Literal*>(node)) {
        return visitLiteral(literal);
    } else if (auto binaryOp = dynamic_cast<BinaryOp*>(node)) {
        return visitBinaryOp(binaryOp);
    } else if (auto funcCall = dynamic_cast<FunctionCall*>(node)) {
        return visitFunctionCall(funcCall);
    }

    std::cerr << "‚ö†Ô∏è Êú™ËØÜÂà´ÁöÑASTËäÇÁÇπÁ±ªÂûã" << std::endl;
    return ASTValue();
}

ASTValue ASTInterpreter::visitImport(ImportDecl* node) {
    std::cout << "üì¶ ÂØºÂÖ•Ê®°Âùó: " << node->moduleName << std::endl;
    return ASTValue();
}

ASTValue ASTInterpreter::visitVariableDecl(VariableDecl* node) {
    ASTValue value;
    if (node->initializer) {
        value = visit(node->initializer.get());
    }

    environment->define(node->name, value);
    std::cout << "üìù ÂÆö‰πâÂèòÈáè: " << node->name << " = " << value.toString() << std::endl;

    return ASTValue();
}

ASTValue ASTInterpreter::visitFunctionDecl(FunctionDecl* node) {
    // Â∞ÜÂáΩÊï∞Â≠òÂÇ®Ëµ∑Êù•Ôºå‰æõÂêéÁª≠Ë∞ÉÁî®
    std::cout << "üîß ÂÆö‰πâÂáΩÊï∞: " << node->name << std::endl;
    return ASTValue();
}

ASTValue ASTInterpreter::visitStructDecl(StructDecl* node) {
    std::cout << "üèóÔ∏è ÂÆö‰πâÁªìÊûÑ‰Ωì: " << node->name << std::endl;
    return ASTValue();
}

ASTValue ASTInterpreter::visitBlock(Block* node) {
    // ÂàõÂª∫Êñ∞ÁöÑ‰ΩúÁî®Âüü
    auto previous = environment;
    environment = std::make_shared<Environment>(environment);

    ASTValue result;
    for (auto& stmt : node->statements) {
        result = visit(stmt.get());
    }

    // ÊÅ¢Â§ç‰∏ä‰∏ÄÂ±Ç‰ΩúÁî®Âüü
    environment = previous;
    return result;
}

ASTValue ASTInterpreter::visitReturnStmt(ReturnStmt* node) {
    ASTValue value;
    if (node->value) {
        value = visit(node->value.get());
    }

    std::cout << "‚Ü©Ô∏è ËøîÂõûÂÄº: " << value.toString() << std::endl;
    return value;
}

ASTValue ASTInterpreter::visitExpressionStmt(ExpressionStmt* node) {
    return visit(node->expression.get());
}

ASTValue ASTInterpreter::visitIdentifier(Identifier* node) {
    try {
        return environment->get(node->name);
    } catch (const std::runtime_error& e) {
        std::cerr << "‚ùå " << e.what() << std::endl;
        return ASTValue();
    }
}

ASTValue ASTInterpreter::visitLiteral(Literal* node) {
    if (node->type == "int") {
        return ASTValue(std::stoi(node->value));
    } else if (node->type == "float") {
        return ASTValue(std::stod(node->value));
    } else if (node->type == "string") {
        return ASTValue(node->value);
    } else if (node->type == "bool") {
        return ASTValue(node->value == "true");
    }

    return ASTValue();
}

ASTValue ASTInterpreter::visitBinaryOp(BinaryOp* node) {
    ASTValue left = visit(node->left.get());
    ASTValue right = visit(node->right.get());

    if (node->operator_ == "+") {
        if (left.getType() == ASTValue::INT && right.getType() == ASTValue::INT) {
            return ASTValue(left.get<int>() + right.get<int>());
        }
    } else if (node->operator_ == "-") {
        if (left.getType() == ASTValue::INT && right.getType() == ASTValue::INT) {
            return ASTValue(left.get<int>() - right.get<int>());
        }
    } else if (node->operator_ == "*") {
        if (left.getType() == ASTValue::INT && right.getType() == ASTValue::INT) {
            return ASTValue(left.get<int>() * right.get<int>());
        }
    } else if (node->operator_ == "/") {
        if (left.getType() == ASTValue::INT && right.getType() == ASTValue::INT) {
            return ASTValue(left.get<int>() / right.get<int>());
        }
    }

    std::cerr << "‚ö†Ô∏è ‰∏çÊîØÊåÅÁöÑ‰∫åÂÖÉËøêÁÆó: " << node->operator_ << std::endl;
    return ASTValue();
}

ASTValue ASTInterpreter::visitFunctionCall(FunctionCall* node) {
    std::vector<ASTValue> args;
    for (auto& arg : node->arguments) {
        args.push_back(visit(arg.get()));
    }

    return callBuiltinFunction(node->name, args);
}

void ASTInterpreter::setupBuiltins() {
    // ÂÜÖÁΩÆÂáΩÊï∞Â∞ÜÂú®ËøêË°åÊó∂Â§ÑÁêÜ
}

ASTValue ASTInterpreter::callBuiltinFunction(const std::string& name,
                                           const std::vector<ASTValue>& args) {
    if (name == "print" || name == "ÊâìÂç∞") {
        std::cout << "üì¢ ËæìÂá∫: ";
        for (size_t i = 0; i < args.size(); ++i) {
            std::cout << args[i].toString();
            if (i < args.size() - 1) std::cout << " ";
        }
        std::cout << std::endl;
        return ASTValue();
    }

    std::cerr << "‚ùå Êú™Áü•ÁöÑÂÜÖÁΩÆÂáΩÊï∞: " << name << std::endl;
    return ASTValue();
}

// ASTÂèØËßÜÂåñÂô®ÂÆûÁé∞
void ASTVisualizer::printAST(ASTNode* node, int depth) {
    printIndent(depth);
    std::cout << nodeToString(node) << std::endl;

    // ÈÄíÂΩíÊâìÂç∞Â≠êËäÇÁÇπ
    if (auto program = dynamic_cast<Program*>(node)) {
        for (auto& stmt : program->statements) {
            printAST(stmt.get(), depth + 1);
        }
    } else if (auto block = dynamic_cast<Block*>(node)) {
        for (auto& stmt : block->statements) {
            printAST(stmt.get(), depth + 1);
        }
    } else if (auto funcDecl = dynamic_cast<FunctionDecl*>(node)) {
        if (funcDecl->body) {
            printAST(funcDecl->body.get(), depth + 1);
        }
    } else if (auto varDecl = dynamic_cast<VariableDecl*>(node)) {
        if (varDecl->initializer) {
            printAST(varDecl->initializer.get(), depth + 1);
        }
    } else if (auto binaryOp = dynamic_cast<BinaryOp*>(node)) {
        printAST(binaryOp->left.get(), depth + 1);
        printAST(binaryOp->right.get(), depth + 1);
    }
}

void ASTVisualizer::printIndent(int depth) {
    for (int i = 0; i < depth; ++i) {
        std::cout << "  ";
    }
}

std::string ASTVisualizer::nodeToString(ASTNode* node) {
    if (auto program = dynamic_cast<Program*>(node)) {
        return "üåç Program";
    } else if (auto import = dynamic_cast<ImportDecl*>(node)) {
        return "üì¶ Import: " + import->moduleName;
    } else if (auto varDecl = dynamic_cast<VariableDecl*>(node)) {
        return "üìù Variable: " + varDecl->name;
    } else if (auto funcDecl = dynamic_cast<FunctionDecl*>(node)) {
        return "üîß Function: " + funcDecl->name;
    } else if (auto structDecl = dynamic_cast<StructDecl*>(node)) {
        return "üèóÔ∏è Struct: " + structDecl->name;
    } else if (auto block = dynamic_cast<Block*>(node)) {
        return "üì¶ Block";
    } else if (auto returnStmt = dynamic_cast<ReturnStmt*>(node)) {
        return "‚Ü©Ô∏è Return";
    } else if (auto identifier = dynamic_cast<Identifier*>(node)) {
        return "üîó Identifier: " + identifier->name;
    } else if (auto literal = dynamic_cast<Literal*>(node)) {
        return "üíé Literal: " + literal->value + " (" + literal->type + ")";
    } else if (auto binaryOp = dynamic_cast<BinaryOp*>(node)) {
        return "‚öôÔ∏è BinaryOp: " + binaryOp->operator_;
    } else if (auto funcCall = dynamic_cast<FunctionCall*>(node)) {
        return "üìû FunctionCall: " + funcCall->name;
    }

    return "‚ùì Unknown";
}

void ASTVisualizer::exportToJSON(ASTNode* node, const std::string& filename) {
    std::ofstream file(filename);
    file << "{\n  \"type\": \"" << nodeToString(node) << "\"\n}" << std::endl;
    std::cout << "üìÑ ASTÂ∑≤ÂØºÂá∫Âà∞JSON: " << filename << std::endl;
}

void ASTVisualizer::exportToDot(ASTNode* node, const std::string& filename) {
    std::ofstream file(filename);
    file << "digraph AST {\n";
    file << "  node [shape=box];\n";
    file << "  \"root\" [label=\"" << nodeToString(node) << "\"];\n";
    file << "}" << std::endl;
    std::cout << "üé® ASTÂ∑≤ÂØºÂá∫Âà∞DOTÊ†ºÂºè: " << filename << std::endl;
}

// ASTÂàÜÊûêÂô®ÂÆûÁé∞
ASTAnalyzer::AnalysisResult ASTAnalyzer::analyze(Program* program) {
    AnalysisResult result;

    std::cout << "üîç ÂºÄÂßãÂàÜÊûêAST..." << std::endl;

    for (auto& stmt : program->statements) {
        analyzeNode(stmt.get(), result, 0);
    }

    std::cout << "üìä ASTÂàÜÊûêÂÆåÊàê:" << std::endl;
    std::cout << "  - ÊÄªËäÇÁÇπÊï∞: " << result.totalNodes << std::endl;
    std::cout << "  - ÂáΩÊï∞Êï∞Èáè: " << result.functionCount << std::endl;
    std::cout << "  - ÂèòÈáèÊï∞Èáè: " << result.variableCount << std::endl;
    std::cout << "  - ÊúÄÂ§ßÊ∑±Â∫¶: " << result.maxDepth << std::endl;

    return result;
}

void ASTAnalyzer::analyzeNode(ASTNode* node, AnalysisResult& result, int depth) {
    result.totalNodes++;
    result.maxDepth = std::max(result.maxDepth, depth);

    if (dynamic_cast<FunctionDecl*>(node)) {
        result.functionCount++;
    } else if (dynamic_cast<VariableDecl*>(node)) {
        result.variableCount++;
    }

    // ÁªßÁª≠ÂàÜÊûêÂ≠êËäÇÁÇπ...
}

}